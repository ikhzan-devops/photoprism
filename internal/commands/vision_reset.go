package commands

import (
	"fmt"
	"slices"
	"strings"

	"github.com/manifoldco/promptui"
	"github.com/urfave/cli/v2"

	"github.com/photoprism/photoprism/internal/ai/vision"
	"github.com/photoprism/photoprism/internal/config"
	"github.com/photoprism/photoprism/internal/entity"
	"github.com/photoprism/photoprism/internal/entity/search"
	"github.com/photoprism/photoprism/internal/workers"
)

// VisionResetCommand configures the command name, flags, and action.
var VisionResetCommand = &cli.Command{
	Name:      "reset",
	Usage:     "Resets data generated by computer vision models for pictures that match the specified search filters",
	ArgsUsage: "[filter]...",
	Flags: []cli.Flag{
		&cli.StringFlag{
			Name:    "models",
			Aliases: []string{"m"},
			Usage:   "computer vision `MODELS` to reset, e.g. caption or labels",
			Value:   "",
		},
		&cli.IntFlag{
			Name:    "count",
			Aliases: []string{"n"},
			Usage:   "maximum `NUMBER` of pictures to be processed",
			Value:   search.MaxResults,
		},
		&cli.StringFlag{
			Name:    "source",
			Aliases: []string{"s"},
			Usage:   "generated data source `TYPE` to reset, e.g. vision or ollama",
			Value:   entity.SrcVision,
		},
		&cli.BoolFlag{
			Name:    "yes",
			Aliases: []string{"y"},
			Usage:   "runs the command non-interactively",
		},
	},
	Action: visionResetAction,
}

func visionResetAction(ctx *cli.Context) error {
	return CallWithDependencies(ctx, func(conf *config.Config) error {
		models := vision.ParseTypes(ctx.String("models"))
		resetCaptions := slices.Contains(models, vision.ModelTypeCaption)
		resetLabels := slices.Contains(models, vision.ModelTypeLabels)

		if !resetCaptions && !resetLabels {
			log.Warn("vision: no resettable models were specified, nothing to reset")
			return nil
		}

		selectedModels := make([]string, 0, 2)
		if resetCaptions {
			selectedModels = append(selectedModels, vision.ModelTypeCaption)
		}
		if resetLabels {
			selectedModels = append(selectedModels, vision.ModelTypeLabels)
		}

		confirmed := RunNonInteractively(ctx.Bool("yes"))

		if !confirmed && len(selectedModels) > 0 {
			label := fmt.Sprintf("Reset generated %s for matching pictures?", describeVisionModels(selectedModels))
			prompt := promptui.Prompt{Label: label, IsConfirm: true}
			if _, err := prompt.Run(); err != nil {
				return nil
			}
		}

		worker := workers.NewVision(conf)
		filter := strings.TrimSpace(strings.Join(ctx.Args().Slice(), " "))
		return worker.Reset(
			filter,
			ctx.Int("count"),
			selectedModels,
			ctx.String("source"),
		)
	})
}

func describeVisionModels(models []string) string {
	descriptions := make([]string, 0, len(models))

	for _, m := range models {
		switch m {
		case vision.ModelTypeCaption:
			descriptions = append(descriptions, "captions")
		case vision.ModelTypeLabels:
			descriptions = append(descriptions, "labels")
		default:
			descriptions = append(descriptions, m)
		}
	}

	switch len(descriptions) {
	case 0:
		return "metadata"
	case 1:
		return descriptions[0]
	case 2:
		return descriptions[0] + " and " + descriptions[1]
	default:
		head := strings.Join(descriptions[:len(descriptions)-1], ", ")
		return head + ", and " + descriptions[len(descriptions)-1]
	}
}
